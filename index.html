<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
  <title>Offline MP3 Player</title>
  <link rel="manifest" href="/manifest.json">
  <link rel="icon" href="/favicon.ico">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <style>
    body{margin:0;font-family:-apple-system,BlinkMacSystemFont,sans-serif;background:#fff;color:#000}
    header{padding:16px;font-size:18px;font-weight:600;border-bottom:1px solid #ddd}
    main{padding:16px}
    input,button{width:100%;padding:12px;margin:8px 0;font-size:16px;border:1px solid #ccc;border-radius:8px}
    .playlist{margin-top:24px;padding:12px;border:1px solid #ccc;border-radius:12px}
    .playlist img{max-width:100px;display:block;margin:8px 0}
    .song{padding:8px 0;border-bottom:1px solid #eee;display:flex;justify-content:space-between}
    .controls{display:flex;justify-content:space-around;margin:12px 0}
    .controls button{flex:1;margin:0 4px}
    audio{display:none}
  </style>
  <script>
  // Register service worker
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/sw.js').catch(console.error);
  }
  </script>
</head>
<body>
  <header>Offline MP3</header>
  <main>
    <input id="newPlaylistName" placeholder="New Playlist Name">
    <input type="file" id="newPlaylistImage" accept="image/*">
    <button onclick="createPlaylist()">Create Playlist</button>
    <div id="playlists"></div>
    <div class="controls">
      <button onclick="prev()">‚èÆ</button>
      <button onclick="togglePlay()">‚èØ</button>
      <button onclick="next()">‚è≠</button>
      <button onclick="shuffle()">üîÄ</button>
    </div>
    <audio id="audio" controls></audio>
  </main>

  <script>
  const dbName = 'offlineMp3DB';
  let db, playlists = [];
  let currentPlaylist = -1, currentSong = -1;
  const audio = document.getElementById('audio'), playlistsDiv = document.getElementById('playlists');

  // IndexedDB setup
  const request = indexedDB.open(dbName, 1);
  request.onupgradeneeded = e => {
    const idb = e.target.result;
    idb.createObjectStore('playlists', { keyPath: 'id', autoIncrement: true });
    idb.createObjectStore('songs', { keyPath: 'id', autoIncrement: true });
  };
  request.onsuccess = e => {
    db = e.target.result;
    loadAll();
  };

  function loadAll() {
    const tx = db.transaction(['playlists','songs']);
    Promise.all([
      storeGetAll(tx.objectStore('playlists')),
      storeGetAll(tx.objectStore('songs')),
    ]).then(([pls, sgs]) => {
      playlists = pls.map(p => ({
        ...p, songs: sgs.filter(s => s.pid === p.id)
      }));
      render();
    });
  }
  function storeGetAll(store) {
    return new Promise(resolve => {
      const arr=[]; store.openCursor().onsuccess = e => {
        const c = e.target.result;
        if (c) { arr.push(c.value); c.continue(); }
        else resolve(arr);
      };
    });
  }

  function savePlaylist(p) {
    const tx = db.transaction('playlists','readwrite');
    tx.objectStore('playlists').put(p);
  }
  function deletePlaylist(p) {
    const tx = db.transaction(['playlists','songs'],'readwrite');
    tx.objectStore('playlists').delete(p.id);
    db.transaction('songs','readwrite').objectStore('songs')
      .openCursor().onsuccess = e => {
        const c=e.target.result;
        if(c){ if(c.value.pid===p.id) c.delete(); c.continue(); }
      };
  }
  function saveSong(s) {
    const tx = db.transaction('songs','readwrite');
    tx.objectStore('songs').put(s);
  }
  function deleteSong(s) {
    const tx = db.transaction('songs','readwrite');
    tx.objectStore('songs').delete(s.id);
  }

  function createPlaylist() {
    const name = document.getElementById('newPlaylistName').value||'Untitled';
    const imgInp = document.getElementById('newPlaylistImage');
    const imgFile = imgInp.files[0];
    const reader = new FileReader();
    reader.onload = () => {
      const p = { name, image: reader.result };
      const tx = db.transaction('playlists','readwrite');
      const store = tx.objectStore('playlists');
      const req = store.add(p);
      req.onsuccess = () => { p.id=req.result; playlists.push({...p, songs: []}); render(); };
    };
    if (imgFile) reader.readAsDataURL(imgFile);
    else {
      const p = { name, image: null};
      const tx = db.transaction('playlists','readwrite');
      const req = tx.objectStore('playlists').add(p);
      req.onsuccess = () => { p.id=req.result; playlists.push({...p, songs: []}); render(); };
    }
    imgInp.value = ''; document.getElementById('newPlaylistName').value = '';
  }

  function render() {
    playlistsDiv.innerHTML = '';
    playlists.forEach((p,i) => {
      const div = document.createElement('div');
      div.className = 'playlist';
      div.innerHTML = `
        <strong>${p.name}</strong>
        ${p.image?`<img src="${p.image}">`:''}
        <input type="file" accept=".mp3" multiple onchange="addSongs(event,${i})">
        <div id="songs-${p.id}"></div>
        <button onclick="playPlaylist(${i})">Play</button>
        <button onclick="shufflePlaylist(${i})">Shuffle</button>
        <button onclick="removePlaylist(${i})">Delete Playlist</button>
      `;
      playlistsDiv.appendChild(div);
      renderSongs(p);
    });
  }

  function renderSongs(p) {
    const container = document.getElementById(`songs-${p.id}`);
    container.innerHTML = '';
    p.songs.forEach((s,i) => {
      const row = document.createElement('div');
      row.className = 'song';
      row.innerHTML = `
        <input value="${s.title}" oninput="renameSong(${p.id},${s.id},this.value)">
        <button onclick="removeSongUI(${p.id},${s.id})">‚úï</button>
      `;
      container.appendChild(row);
    });
  }

  function addSongs(e, idx) {
    const files = Array.from(e.target.files);
    const p = playlists[idx];
    files.forEach(f => {
      const fr = new FileReader();
      fr.onload = () => {
        const s = { pid: p.id, title: f.name, blob: fr.result };
        const tx = db.transaction('songs','readwrite');
        const req = tx.objectStore('songs').add(s);
        req.onsuccess = () => {
          s.id = req.result;
          p.songs.push(s);
          renderSongs(p);
        };
      };
      fr.readAsArrayBuffer(f);
    });
    e.target.value='';
  }

  function renameSong(pid,sid,newTitle) {
    const p=playlists.find(x=>x.id===pid);
    const s=p.songs.find(x=>x.id===sid);
    s.title=newTitle;
    saveSong(s);
  }

  function removeSongUI(pid,sid) {
    const p=playlists.find(x=>x.id===pid);
    const idx=p.songs.findIndex(x=>x.id===sid);
    if(idx>-1) { deleteSong(p.songs[idx]); p.songs.splice(idx,1); renderSongs(p); }
  }

  function removePlaylist(idx) {
    deletePlaylist(playlists[idx]);
    playlists.splice(idx,1);
    render();
  }

  function playPlaylist(i) { currentPlaylist=i; currentSong=0; playCurrent(); }
  function shufflePlaylist(i) {
    const arr=playlists[i].songs;
    for(let j=arr.length-1;j>0;j--){
      const k=Math.floor(Math.random()*(j+1));
      [arr[j],arr[k]]=[arr[k],arr[j]];
    }
    playPlaylist(i);
  }
  function playCurrent() {
    const p=playlists[currentPlaylist],s=p?.songs[currentSong];
    if(!s)return;
    const blob = new Blob([s.blob], { type: 'audio/mp3' });
    audio.src = URL.createObjectURL(blob);
    audio.play();
  }
  function togglePlay(){ audio.paused ? audio.play() : audio.pause(); }
  function next(){ currentSong = (currentSong+1) % playlists[currentPlaylist].songs.length; playCurrent(); }
  function prev(){ currentSong = (currentSong-1+playlists[currentPlaylist].songs.length) % playlists[currentPlaylist].songs.length; playCurrent(); }
  function shuffle(){ if(currentPlaylist>-1) shufflePlaylist(currentPlaylist); }
  audio.onended = next;
  </script>
</body>
</html>